using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace EasyAppDev.Blazor.AutoComplete.Generators;

[Generator]
public class PropertyAccessorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find AutoComplete component usages
        var autoCompleteUsages = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsAutoCompleteComponent(node),
                transform: static (ctx, _) => GetAutoCompleteInfo(ctx))
            .Where(static info => info is not null);

        // Generate accessor code
        context.RegisterSourceOutput(autoCompleteUsages, GenerateAccessorCode!);
    }

    private static bool IsAutoCompleteComponent(SyntaxNode node)
    {
        // Look for component tags like <AutoComplete ...>
        if (node is not GenericNameSyntax genericName)
        {
            return false;
        }

        return genericName.Identifier.Text == "AutoComplete";
    }

    private static AutoCompleteInfo? GetAutoCompleteInfo(GeneratorSyntaxContext context)
    {
        var genericName = (GenericNameSyntax)context.Node;

        // Get the TItem type argument
        if (genericName.TypeArgumentList.Arguments.Count == 0)
        {
            return null;
        }

        var itemType = context.SemanticModel.GetTypeInfo(genericName.TypeArgumentList.Arguments[0]).Type;
        if (itemType is null)
        {
            return null;
        }

        return new AutoCompleteInfo
        {
            ItemTypeName = itemType.ToDisplayString(),
            ItemTypeNamespace = itemType.ContainingNamespace?.ToDisplayString() ?? string.Empty
        };
    }

    private static void GenerateAccessorCode(SourceProductionContext context, AutoCompleteInfo info)
    {
        var itemTypeName = info.ItemTypeName;
        var safeTypeName = itemTypeName.Replace(".", "_").Replace("<", "_").Replace(">", "_");

        var source = $$"""
            // <auto-generated/>
            #nullable enable

            namespace EasyAppDev.Blazor.AutoComplete.Generated
            {
                /// <summary>
                /// Generated property accessors for {{itemTypeName}}
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{nameof(PropertyAccessorGenerator)}}", "1.0.0")]
                internal static class AutoCompleteAccessors_{{safeTypeName}}
                {
                    /// <summary>
                    /// Compiles an expression to a delegate for efficient property access.
                    /// This method is AOT-friendly and does not use reflection.
                    /// </summary>
                    public static global::System.Func<TItem, string> CompileTextFieldAccessor<TItem>(
                        global::System.Linq.Expressions.Expression<global::System.Func<TItem, string>> expression)
                    {
                        // For AOT scenarios, we compile the expression at build time
                        return expression.Compile();
                    }

                    /// <summary>
                    /// Compiles an expression to a delegate for efficient property access.
                    /// This method is AOT-friendly and does not use reflection.
                    /// </summary>
                    public static global::System.Func<TItem, object> CompileValueFieldAccessor<TItem>(
                        global::System.Linq.Expressions.Expression<global::System.Func<TItem, object>> expression)
                    {
                        return expression.Compile();
                    }
                }
            }
            """;

        context.AddSource($"AutoCompleteAccessors_{safeTypeName}.g.cs", source);
    }

    private class AutoCompleteInfo
    {
        public string ItemTypeName { get; set; } = string.Empty;
        public string ItemTypeNamespace { get; set; } = string.Empty;
    }
}
